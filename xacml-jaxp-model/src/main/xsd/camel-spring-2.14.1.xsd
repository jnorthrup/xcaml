<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified"
           version="1.0"
           targetNamespace="http://camel.apache.org/schema/spring"
           xmlns="http://camel.apache.org/schema/spring"
           xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="aggregate">
        <xs:complexType id="aggregateDefinition">
            <xs:complexContent>
                <xs:extension base="processorDefinition">
                    <xs:sequence>
                        <xs:element name="correlationExpression" type="expressionSubElementDefinition"/>
                        <xs:element name="completionPredicate" type="expressionSubElementDefinition" minOccurs="0"/>
                        <xs:element name="completionTimeout" type="expressionSubElementDefinition" minOccurs="0"/>
                        <xs:element name="completionSize" type="expressionSubElementDefinition" minOccurs="0"/>
                        <xs:element ref="optimisticLockRetryPolicy" minOccurs="0"/>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:element ref="aop"/>
                            <xs:element ref="aggregate"/>
                            <xs:element ref="bean"/>
                            <xs:element ref="doCatch"/>
                            <xs:element ref="when"/>
                            <xs:element ref="choice"/>
                            <xs:element ref="otherwise"/>
                            <xs:element ref="convertBodyTo"/>
                            <xs:element ref="delay"/>
                            <xs:element ref="dynamicRouter"/>
                            <xs:element ref="enrich"/>
                            <xs:element ref="filter"/>
                            <xs:element ref="doFinally"/>
                            <xs:element ref="idempotentConsumer"/>
                            <xs:element ref="inOnly"/>
                            <xs:element ref="inOut"/>
                            <xs:element ref="intercept"/>
                            <xs:element ref="interceptFrom"/>
                            <xs:element ref="interceptToEndpoint"/>
                            <xs:element ref="loadBalance"/>
                            <xs:element ref="log"/>
                            <xs:element ref="loop"/>
                            <xs:element ref="marshal"/>
                            <xs:element ref="multicast"/>
                            <xs:element ref="onCompletion"/>
                            <xs:element ref="onException"/>
                            <xs:element ref="pipeline"/>
                            <xs:element ref="policy"/>
                            <xs:element ref="pollEnrich"/>
                            <xs:element ref="process"/>
                            <xs:element ref="recipientList"/>
                            <xs:element ref="removeHeader"/>
                            <xs:element ref="removeHeaders"/>
                            <xs:element ref="removeProperty"/>
                            <xs:element ref="resequence"/>
                            <xs:element ref="rollback"/>
                            <xs:element ref="route"/>
                            <xs:element ref="routingSlip"/>
                            <xs:element ref="sample"/>
                            <xs:element ref="setBody"/>
                            <xs:element ref="setExchangePattern"/>
                            <xs:element ref="setFaultBody"/>
                            <xs:element ref="setHeader"/>
                            <xs:element ref="setOutHeader"/>
                            <xs:element ref="setProperty"/>
                            <xs:element ref="sort"/>
                            <xs:element ref="split"/>
                            <xs:element ref="stop"/>
                            <xs:element ref="threads"/>
                            <xs:element ref="throttle"/>
                            <xs:element ref="throwException"/>
                            <xs:element ref="to"/>
                            <xs:element ref="transacted"/>
                            <xs:element ref="transform"/>
                            <xs:element ref="doTry"/>
                            <xs:element ref="unmarshal"/>
                            <xs:element ref="validate"/>
                            <xs:element ref="wireTap"/>
                            <xs:element ref="restBinding"/>
                        </xs:choice>
                    </xs:sequence>
                    <xs:attribute name="parallelProcessing" type="xs:boolean"/>
                    <xs:attribute name="optimisticLocking" type="xs:boolean"/>
                    <xs:attribute name="executorServiceRef" type="xs:string"/>
                    <xs:attribute name="timeoutCheckerExecutorServiceRef" type="xs:string"/>
                    <xs:attribute name="aggregationRepositoryRef" type="xs:string"/>
                    <xs:attribute name="strategyRef" type="xs:string"/>
                    <xs:attribute name="strategyMethodName" type="xs:string"/>
                    <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                    <xs:attribute name="completionSize" type="xs:int"/>
                    <xs:attribute name="completionInterval" type="xs:long"/>
                    <xs:attribute name="completionTimeout" type="xs:long"/>
                    <xs:attribute name="completionFromBatchConsumer" type="xs:boolean"/>
                    <xs:attribute name="groupExchanges" type="xs:boolean"/>
                    <xs:attribute name="eagerCheckCompletion" type="xs:boolean"/>
                    <xs:attribute name="ignoreInvalidCorrelationKeys" type="xs:boolean"/>
                    <xs:attribute name="closeCorrelationKeyOnCompletion" type="xs:int"/>
                    <xs:attribute name="discardOnCompletionTimeout" type="xs:boolean"/>
                    <xs:attribute name="forceCompletionOnStop" type="xs:boolean"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="aop" type="aopDefinition"/>

    <xs:element name="avro" type="avroDataFormat"/>

    <xs:element name="barcode">
        <xs:complexType mixed="true" id="barcodeDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="width" type="xs:int"/>
                    <xs:attribute name="height" type="xs:int"/>
                    <xs:attribute name="imageType" type="xs:string"/>
                    <xs:attribute name="barcodeFormat" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="base64">
        <xs:complexType id="base64DataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="lineLength" type="xs:int"/>
                    <xs:attribute name="lineSeparator" type="xs:string"/>
                    <xs:attribute name="urlSafe" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="batchResequencerConfig" type="batchResequencerConfig"/>

    <xs:element name="bean">
        <xs:complexType id="beanDefinition">
            <xs:complexContent>
                <xs:extension base="noOutputDefinition">
                    <xs:sequence/>
                    <xs:attribute name="ref" type="xs:string"/>
                    <xs:attribute name="method" type="xs:string"/>
                    <xs:attribute name="beanType" type="xs:string"/>
                    <xs:attribute name="cache" type="xs:boolean"/>
                    <xs:attribute name="multiParameterArray" type="xs:boolean"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="beanPostProcessor">
        <xs:complexType id="camelBeanPostProcessor">
            <xs:sequence/>
        </xs:complexType>
    </xs:element>

    <xs:element name="beanio">
        <xs:complexType id="beanioDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="mapping" type="xs:string" use="required"/>
                    <xs:attribute name="streamName" type="xs:string" use="required"/>
                    <xs:attribute name="ignoreUnidentifiedRecords" type="xs:boolean"/>
                    <xs:attribute name="ignoreUnexpectedRecords" type="xs:boolean"/>
                    <xs:attribute name="ignoreInvalidRecords" type="xs:boolean"/>
                    <xs:attribute name="encoding" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="bindy" type="bindyDataFormat"/>

    <xs:element name="castor" type="castorDataFormat"/>

    <xs:element name="choice">
        <xs:complexType id="choiceDefinition">
            <xs:complexContent>
                <xs:extension base="processorDefinition">
                    <xs:sequence>
                        <xs:element ref="when" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="otherwise" minOccurs="0"/>
                    </xs:sequence>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="circuitBreaker" type="circuitBreakerLoadBalancerDefinition"/>

    <xs:element name="constant">
        <xs:complexType id="constantExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="consumerTemplate" type="camelConsumerTemplateFactoryBean"/>

    <xs:element name="contextScan">
        <xs:complexType id="contextScanDefinition">
            <xs:sequence>
                <xs:element name="excludes" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="includes" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>

    </xs:element>

    <xs:element name="convertBodyTo" type="convertBodyDefinition"/>

    <xs:element name="crypto" type="cryptoDataFormat"/>

    <xs:element name="csv" type="csvDataFormat"/>

    <xs:element name="customDataFormat" type="customDataFormat"/>

    <xs:element name="customLoadBalancer" type="customLoadBalancerDefinition"/>

    <xs:element name="dataFormats" type="dataFormatsDefinition"/>

    <xs:element name="delay">
        <xs:complexType id="delayDefinition">
            <xs:complexContent>
                <xs:extension base="expressionNode">
                    <xs:sequence/>
                    <xs:attribute name="executorServiceRef" type="xs:string"/>
                    <xs:attribute name="asyncDelayed" type="xs:boolean"/>
                    <xs:attribute name="callerRunsWhenRejected" type="xs:boolean"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="delete" type="deleteVerbDefinition"/>

    <xs:element name="description">
        <xs:complexType id="descriptionDefinition">
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="lang" type="xs:string"/>
                    <xs:attribute name="layoutX" type="xs:double"/>
                    <xs:attribute name="layoutY" type="xs:double"/>
                    <xs:attribute name="layoutWidth" type="xs:double"/>
                    <xs:attribute name="layoutHeight" type="xs:double"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="doCatch" type="catchDefinition"/>

    <xs:element name="doFinally" type="finallyDefinition"/>

    <xs:element name="doTry" type="tryDefinition"/>

    <xs:element name="dynamicRouter" type="dynamicRouterDefinition"/>

    <xs:element name="el">
        <xs:complexType id="elExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="endpoint">
        <xs:complexType id="camelEndpointFactoryBean">
            <xs:complexContent>
                <xs:extension base="abstractCamelEndpointFactoryBean">
                    <xs:sequence/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="enrich" type="enrichDefinition"/>

    <xs:element name="errorHandler" type="errorHandlerDefinition"/>

    <xs:element name="export">
        <xs:complexType id="camelServiceExporterDefinition">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence/>
                    <xs:attribute name="uri" type="xs:string"/>
                    <xs:attribute name="serviceRef" type="xs:string"/>
                    <xs:attribute name="serviceInterface" type="xs:string"/>
                    <xs:attribute name="camelContextId" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="expression" type="expressionSubElementDefinition"/>

    <xs:element name="expressionDefinition" type="expression"/>

    <xs:element name="failover" type="failoverLoadBalancerDefinition"/>

    <xs:element name="filter">
        <xs:complexType id="filterDefinition">
            <xs:complexContent>
                <xs:extension base="expressionNode">
                    <xs:sequence/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="flatpack" type="flatpackDataFormat"/>

    <xs:element name="from">
        <xs:complexType id="fromDefinition">
            <xs:complexContent>
                <xs:extension base="optionalIdentifiedDefinition">
                    <xs:sequence/>
                    <xs:attribute name="uri" type="xs:string"/>
                    <xs:attribute name="ref" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="get" type="getVerbDefinition"/>

    <xs:element name="groovy">
        <xs:complexType id="groovyExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="gzip" type="gzipDataFormat"/>

    <xs:element name="head" type="headVerbDefinition"/>

    <xs:element name="header">
        <xs:complexType id="headerExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>


    </xs:element>

    <xs:element name="hl7" type="hl7DataFormat"/>

    <xs:element name="idempotentConsumer" type="idempotentConsumerDefinition"/>

    <xs:element name="inOnly" type="inOnlyDefinition"/>

    <xs:element name="inOut" type="inOutDefinition"/>

    <xs:element name="intercept" type="interceptDefinition"/>

    <xs:element name="interceptFrom" type="interceptFromDefinition"/>

    <xs:element name="interceptToEndpoint" type="interceptSendToEndpointDefinition"/>

    <xs:element name="javaScript">
        <xs:complexType id="javaScriptExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="jaxb">
        <xs:complexType id="jaxbDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="contextPath" type="xs:string" use="required"/>
                    <xs:attribute name="schema" type="xs:string"/>
                    <xs:attribute name="prettyPrint" type="xs:boolean"/>
                    <xs:attribute name="ignoreJAXBElement" type="xs:boolean"/>
                    <xs:attribute name="mustBeJAXBElement" type="xs:boolean"/>
                    <xs:attribute name="filterNonXmlChars" type="xs:boolean"/>
                    <xs:attribute name="encoding" type="xs:string"/>
                    <xs:attribute name="fragment" type="xs:boolean"/>
                    <xs:attribute name="partClass" type="xs:string"/>
                    <xs:attribute name="partNamespace" type="xs:string"/>
                    <xs:attribute name="namespacePrefixRef" type="xs:string"/>
                    <xs:attribute name="xmlStreamWriterWrapper" type="xs:string"/>
                    <xs:attribute name="schemaLocation" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="jibx" type="jibxDataFormat"/>

    <xs:element name="jmxAgent">
        <xs:complexType id="camelJMXAgentDefinition">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence/>
                    <xs:attribute name="disabled" type="xs:string"/>
                    <xs:attribute name="onlyRegisterProcessorWithCustomId" type="xs:string"/>
                    <xs:attribute name="registryPort" type="xs:string"/>
                    <xs:attribute name="connectorPort" type="xs:string"/>
                    <xs:attribute name="mbeanServerDefaultDomain" type="xs:string"/>
                    <xs:attribute name="mbeanObjectDomainName" type="xs:string"/>
                    <xs:attribute name="serviceUrlPath" type="xs:string"/>
                    <xs:attribute name="createConnector" type="xs:string"/>
                    <xs:attribute name="usePlatformMBeanServer" type="xs:string"/>
                    <xs:attribute name="registerAlways" type="xs:string"/>
                    <xs:attribute name="registerNewRoutes" type="xs:string"/>
                    <xs:attribute name="statisticsLevel" type="xs:string"/>
                    <xs:attribute name="loadStatisticsEnabled" type="xs:string"/>
                    <xs:attribute name="includeHostName" type="xs:string"/>
                    <xs:attribute name="mask" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="json">
        <xs:complexType id="jsonDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="prettyPrint" type="xs:boolean"/>
                    <xs:attribute name="library" type="jsonLibrary"/>
                    <xs:attribute name="unmarshalTypeName" type="xs:string"/>
                    <xs:attribute name="jsonView" type="xs:string"/>
                    <xs:attribute name="include" type="xs:string"/>
                    <xs:attribute name="allowJmsType" type="xs:boolean"/>
                    <xs:attribute name="collectionTypeName" type="xs:string"/>
                    <xs:attribute name="useList" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="jsonpath">
        <xs:complexType id="jsonPathExpression">
            <xs:simpleContent>
                <xs:extension base="expression">
                    <xs:attribute name="resultType" type="xs:string"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="jxpath">
        <xs:complexType id="jxPathExpression">
            <xs:simpleContent>
                <xs:extension base="expression">
                    <xs:attribute name="lenient" type="xs:boolean"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="keyStoreParameters" type="keyStoreParametersFactoryBean"/>

    <xs:element name="language">
        <xs:complexType id="languageExpression">
            <xs:simpleContent>
                <xs:extension base="expression">
                    <xs:attribute name="language" type="xs:string" use="required"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="loadBalance" type="loadBalanceDefinition"/>

    <xs:element name="log">
        <xs:complexType id="logDefinition">
            <xs:complexContent>
                <xs:extension base="noOutputDefinition">
                    <xs:sequence/>
                    <xs:attribute name="message" type="xs:string" use="required"/>
                    <xs:attribute name="loggingLevel" type="loggingLevel"/>
                    <xs:attribute name="logName" type="xs:string"/>
                    <xs:attribute name="marker" type="xs:string"/>
                    <xs:attribute name="loggerRef" type="xs:string"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="loop" type="loopDefinition"/>

    <xs:element name="marshal" type="marshalDefinition"/>

    <xs:element name="method">
        <xs:complexType id="methodCallExpression">
            <xs:simpleContent>
                <xs:extension base="expression">
                    <xs:attribute name="bean" type="xs:string"/>
                    <xs:attribute name="ref" type="xs:string"/>
                    <xs:attribute name="method" type="xs:string"/>
                    <xs:attribute name="beanType" type="xs:string"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="multicast" type="multicastDefinition"/>

    <xs:element name="mvel">
        <xs:complexType id="mvelExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="ognl">
        <xs:complexType id="ognlExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="onCompletion" type="onCompletionDefinition"/>

    <xs:element name="onException" type="onExceptionDefinition"/>

    <xs:element name="optimisticLockRetryPolicy" type="optimisticLockRetryPolicyDefinition"/>

    <xs:element name="otherwise">
        <xs:complexType id="otherwiseDefinition">
            <xs:complexContent>
                <xs:extension base="output">
                    <xs:sequence/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="packageScan">
        <xs:complexType id="packageScanDefinition">
            <xs:sequence>
                <xs:element name="package" type="xs:string" maxOccurs="unbounded"/>
                <xs:element name="excludes" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="includes" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>

    </xs:element>

    <xs:element name="pgp" type="pgpDataFormat"/>

    <xs:element name="php">
        <xs:complexType id="phpExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="pipeline">
        <xs:complexType id="pipelineDefinition">
            <xs:complexContent>
                <xs:extension base="output">
                    <xs:sequence/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="policy" type="policyDefinition"/>

    <xs:element name="pollEnrich" type="pollEnrichDefinition"/>

    <xs:element name="post" type="postVerbDefinition"/>

    <xs:element name="process">
        <xs:complexType id="processDefinition">
            <xs:complexContent>
                <xs:extension base="noOutputDefinition">
                    <xs:sequence/>
                    <xs:attribute name="ref" type="xs:string" use="required"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="properties">
        <xs:complexType id="propertiesDefinition">
            <xs:sequence>
                <xs:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="propertiesFunction" type="camelPropertyPlaceholderFunctionDefinition"/>

    <xs:element name="property" nillable="true" type="xs:anyType"/>

    <xs:element name="propertyPlaceholder">
        <xs:complexType id="camelPropertyPlaceholderDefinition">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence>
                        <xs:element ref="propertiesFunction" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="location" type="xs:string" use="required"/>
                    <xs:attribute name="cache" type="xs:boolean"/>
                    <xs:attribute name="ignoreMissingLocation" type="xs:boolean"/>
                    <xs:attribute name="propertiesResolverRef" type="xs:string"/>
                    <xs:attribute name="propertiesParserRef" type="xs:string"/>
                    <xs:attribute name="propertyPrefix" type="xs:string"/>
                    <xs:attribute name="propertySuffix" type="xs:string"/>
                    <xs:attribute name="fallbackToUnaugmentedProperty" type="xs:boolean"/>
                    <xs:attribute name="prefixToken" type="xs:string"/>
                    <xs:attribute name="suffixToken" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="protobuf" type="protobufDataFormat"/>

    <xs:element name="proxy" type="camelProxyFactoryDefinition"/>

    <xs:element name="put">
        <xs:complexType id="putVerbDefinition">
            <xs:complexContent>
                <xs:extension base="verbDefinition">
                    <xs:sequence/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="python">
        <xs:complexType id="pythonExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="random" type="randomLoadBalancerDefinition"/>

    <xs:element name="recipientList" type="recipientListDefinition"/>

    <xs:element name="redeliveryPolicy" type="redeliveryPolicyDefinition"/>

    <xs:element name="redeliveryPolicyProfile" type="camelRedeliveryPolicyFactoryBean"/>

    <xs:element name="ref">
        <xs:complexType id="refExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="removeHeader" type="removeHeaderDefinition"/>

    <xs:element name="removeHeaders" type="removeHeadersDefinition"/>

    <xs:element name="removeProperty" type="removePropertyDefinition"/>

    <xs:element name="resequence" type="resequenceDefinition"/>

    <xs:element name="rest" type="restDefinition"/>

    <xs:element name="restBinding">
        <xs:complexType id="restBindingDefinition">
            <xs:complexContent>
                <xs:extension base="noOutputDefinition">
                    <xs:sequence/>
                    <xs:attribute name="consumes" type="xs:string"/>
                    <xs:attribute name="produces" type="xs:string"/>
                    <xs:attribute name="bindingMode" type="restBindingMode"/>
                    <xs:attribute name="type" type="xs:string"/>
                    <xs:attribute name="outType" type="xs:string"/>
                    <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean"/>
                    <xs:attribute name="enableCORS" type="xs:boolean"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="restConfiguration" type="restConfigurationDefinition"/>

    <xs:element name="restContext">
        <xs:complexType id="camelRestContextFactoryBean">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence>
                        <xs:element ref="rest" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="restContextRef" type="restContextRefDefinition"/>

    <xs:element name="restProperty" type="restPropertyDefinition"/>

    <xs:element name="rests" type="restsDefinition"/>

    <xs:element name="rollback" type="rollbackDefinition"/>

    <xs:element name="roundRobin" type="roundRobinLoadBalancerDefinition"/>

    <xs:element name="route">
        <xs:complexType id="routeDefinition">
            <xs:complexContent>
                <xs:extension base="processorDefinition">
                    <xs:sequence>
                        <xs:element ref="from" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:element ref="aop"/>
                            <xs:element ref="aggregate"/>
                            <xs:element ref="bean"/>
                            <xs:element ref="doCatch"/>
                            <xs:element ref="when"/>
                            <xs:element ref="choice"/>
                            <xs:element ref="otherwise"/>
                            <xs:element ref="convertBodyTo"/>
                            <xs:element ref="delay"/>
                            <xs:element ref="dynamicRouter"/>
                            <xs:element ref="enrich"/>
                            <xs:element ref="filter"/>
                            <xs:element ref="doFinally"/>
                            <xs:element ref="idempotentConsumer"/>
                            <xs:element ref="inOnly"/>
                            <xs:element ref="inOut"/>
                            <xs:element ref="intercept"/>
                            <xs:element ref="interceptFrom"/>
                            <xs:element ref="interceptToEndpoint"/>
                            <xs:element ref="loadBalance"/>
                            <xs:element ref="log"/>
                            <xs:element ref="loop"/>
                            <xs:element ref="marshal"/>
                            <xs:element ref="multicast"/>
                            <xs:element ref="onCompletion"/>
                            <xs:element ref="onException"/>
                            <xs:element ref="pipeline"/>
                            <xs:element ref="policy"/>
                            <xs:element ref="pollEnrich"/>
                            <xs:element ref="process"/>
                            <xs:element ref="recipientList"/>
                            <xs:element ref="removeHeader"/>
                            <xs:element ref="removeHeaders"/>
                            <xs:element ref="removeProperty"/>
                            <xs:element ref="resequence"/>
                            <xs:element ref="rollback"/>
                            <xs:element ref="route"/>
                            <xs:element ref="routingSlip"/>
                            <xs:element ref="sample"/>
                            <xs:element ref="setBody"/>
                            <xs:element ref="setExchangePattern"/>
                            <xs:element ref="setFaultBody"/>
                            <xs:element ref="setHeader"/>
                            <xs:element ref="setOutHeader"/>
                            <xs:element ref="setProperty"/>
                            <xs:element ref="sort"/>
                            <xs:element ref="split"/>
                            <xs:element ref="stop"/>
                            <xs:element ref="threads"/>
                            <xs:element ref="throttle"/>
                            <xs:element ref="throwException"/>
                            <xs:element ref="to"/>
                            <xs:element ref="transacted"/>
                            <xs:element ref="transform"/>
                            <xs:element ref="doTry"/>
                            <xs:element ref="unmarshal"/>
                            <xs:element ref="validate"/>
                            <xs:element ref="wireTap"/>
                            <xs:element ref="restBinding"/>
                        </xs:choice>
                    </xs:sequence>
                    <xs:attribute name="autoStartup" type="xs:string"/>
                    <xs:attribute name="delayer" type="xs:string"/>
                    <xs:attribute name="errorHandlerRef" type="xs:string"/>
                    <xs:attribute name="group" type="xs:string"/>
                    <xs:attribute name="handleFault" type="xs:string"/>
                    <xs:attribute name="messageHistory" type="xs:string"/>
                    <xs:attribute name="rest" type="xs:boolean"/>
                    <xs:attribute name="routePolicyRef" type="xs:string"/>
                    <xs:attribute name="shutdownRoute" type="shutdownRoute"/>
                    <xs:attribute name="shutdownRunningTask" type="shutdownRunningTask"/>
                    <xs:attribute name="startupOrder" type="xs:int"/>
                    <xs:attribute name="streamCache" type="xs:string"/>
                    <xs:attribute name="trace" type="xs:string"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="routeBuilder">
        <xs:complexType id="routeBuilderDefinition">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence/>
                    <xs:attribute name="ref" type="xs:string" use="required"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="routeContext">
        <xs:complexType id="camelRouteContextFactoryBean">
            <xs:complexContent>
                <xs:extension base="identifiedType">
                    <xs:sequence>
                        <xs:element ref="route" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="routeContextRef" type="routeContextRefDefinition"/>

    <xs:element name="routes">
        <xs:complexType id="routesDefinition">
            <xs:complexContent>
                <xs:extension base="optionalIdentifiedDefinition">
                    <xs:sequence>
                        <xs:element ref="route" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="routingSlip" type="routingSlipDefinition"/>

    <xs:element name="rss" type="rssDataFormat"/>

    <xs:element name="ruby">
        <xs:complexType id="rubyExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="sample" type="samplingDefinition"/>

    <xs:element name="secureRandomParameters" type="secureRandomParametersFactoryBean"/>

    <xs:element name="secureXML" type="xmlSecurityDataFormat"/>

    <xs:element name="serialization" type="serializationDataFormat"/>

    <xs:element name="setBody" type="setBodyDefinition"/>

    <xs:element name="setExchangePattern" type="setExchangePatternDefinition"/>

    <xs:element name="setFaultBody" type="setFaultBodyDefinition"/>

    <xs:element name="setHeader" type="setHeaderDefinition"/>

    <xs:element name="setOutHeader" type="setOutHeaderDefinition"/>

    <xs:element name="setProperty" type="setPropertyDefinition"/>

    <xs:element name="simple">
        <xs:complexType id="simpleExpression">
            <xs:simpleContent>
                <xs:extension base="expression">
                    <xs:attribute name="resultType" type="xs:string"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="soapjaxb" type="soapJaxbDataFormat"/>

    <xs:element name="sort" type="sortDefinition"/>

    <xs:element name="spel" type="spELExpression"/>

    <xs:element name="split" type="splitDefinition"/>

    <xs:element name="sql">
        <xs:complexType id="sqlExpression">
            <xs:simpleContent>
                <xs:extension base="expression"/>
            </xs:simpleContent>
        </xs:complexType>

    </xs:element>

    <xs:element name="sslContextParameters" type="sslContextParametersFactoryBean"/>

    <xs:element name="sticky" type="stickyLoadBalancerDefinition"/>

    <xs:element name="stop" type="stopDefinition"/>

    <xs:element name="streamCaching" type="camelStreamCachingStrategyDefinition"/>

    <xs:element name="streamResequencerConfig" type="streamResequencerConfig"/>

    <xs:element name="string">
        <xs:complexType id="stringDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                    <xs:attribute name="charset" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="syslog">
        <xs:complexType id="syslogDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="template" type="camelProducerTemplateFactoryBean"/>

    <xs:element name="threadPool" type="camelThreadPoolFactoryBean"/>

    <xs:element name="threadPoolProfile" type="threadPoolProfileDefinition"/>

    <xs:element name="threads" type="threadsDefinition"/>

    <xs:element name="throttle" type="throttleDefinition"/>

    <xs:element name="throwException" type="throwExceptionDefinition"/>

    <xs:element name="tidyMarkup" type="tidyMarkupDataFormat"/>

    <xs:element name="to">
        <xs:complexType id="toDefinition">
            <xs:complexContent>
                <xs:extension base="sendDefinition">
                    <xs:sequence/>
                    <xs:attribute name="pattern" type="exchangePattern"/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="tokenize" type="tokenizerExpression"/>

    <xs:element name="topic" type="topicLoadBalancerDefinition"/>

    <xs:element name="transacted" type="transactedDefinition"/>

    <xs:element name="transform">
        <xs:complexType id="transformDefinition">
            <xs:complexContent>
                <xs:extension base="noOutputExpressionNode">
                    <xs:sequence/>
                    <xs:anyAttribute namespace="##other" processContents="skip"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="unmarshal" type="unmarshalDefinition"/>

    <xs:element name="validate" type="validateDefinition"/>

    <xs:element name="verb" type="verbDefinition"/>

    <xs:element name="vtdxml" type="vtdXmlExpression"/>

    <xs:element name="weighted" type="weightedLoadBalancerDefinition"/>

    <xs:element name="when" type="whenDefinition"/>

    <xs:element name="wireTap" type="wireTapDefinition"/>

    <xs:element name="xmlBeans" type="xmlBeansDataFormat"/>

    <xs:element name="xmljson" type="xmlJsonDataFormat"/>

    <xs:element name="xmlrpc" type="xmlRpcDataFormat"/>

    <xs:element name="xpath">
        <xs:complexType id="xPathExpression">
            <xs:simpleContent>
                <xs:extension base="namespaceAwareExpression">
                    <xs:attribute name="resultType" type="xs:string"/>
                    <xs:attribute name="saxon" type="xs:boolean"/>
                    <xs:attribute name="factoryRef" type="xs:string"/>
                    <xs:attribute name="objectModel" type="xs:string"/>
                    <xs:attribute name="logNamespaces" type="xs:boolean"/>
                    <xs:attribute name="headerName" type="xs:string"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="xquery">
        <xs:complexType id="xQueryExpression">
            <xs:simpleContent>
                <xs:extension base="namespaceAwareExpression">
                    <xs:attribute name="type" type="xs:string"/>
                    <xs:attribute name="headerName" type="xs:string"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="xstream">
        <xs:complexType id="xStreamDataFormat">
            <xs:complexContent>
                <xs:extension base="dataFormat">
                    <xs:sequence>
                        <xs:element name="converters" type="converterList" minOccurs="0"/>
                        <xs:element name="aliases" type="aliasList" minOccurs="0"/>
                        <xs:element name="omitFields" type="omitFieldList" minOccurs="0"/>
                        <xs:element name="implicitCollections" type="implicitCollectionList" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute name="encoding" type="xs:string"/>
                    <xs:attribute name="driver" type="xs:string"/>
                    <xs:attribute name="driverRef" type="xs:string"/>
                    <xs:attribute name="mode" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="xtokenize" type="xmlTokenizerExpression"/>

    <xs:element name="zip" type="zipDataFormat"/>

    <xs:element name="zipFile" type="zipFileDataFormat"/>

    <xs:complexType name="abstractCamelConsumerTemplateFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
                <xs:attribute name="maximumCacheSize" type="xs:int"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractCamelFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
                <xs:attribute name="camelContextId" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="identifiedType" abstract="true">
        <xs:sequence/>
        <xs:attribute name="id" type="xs:ID"/>
    </xs:complexType>

    <xs:complexType name="abstractCamelContextFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractCamelEndpointFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
                <xs:attribute name="singleton" type="xs:boolean"/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="pattern" type="exchangePattern"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractCamelProducerTemplateFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
                <xs:attribute name="defaultEndpoint" type="xs:string"/>
                <xs:attribute name="maximumCacheSize" type="xs:int"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractCamelRedeliveryPolicyFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
                <xs:attribute name="maximumRedeliveries" type="xs:string"/>
                <xs:attribute name="redeliveryDelay" type="xs:string"/>
                <xs:attribute name="asyncDelayedRedelivery" type="xs:string"/>
                <xs:attribute name="backOffMultiplier" type="xs:string"/>
                <xs:attribute name="useExponentialBackOff" type="xs:string"/>
                <xs:attribute name="collisionAvoidanceFactor" type="xs:string"/>
                <xs:attribute name="useCollisionAvoidance" type="xs:string"/>
                <xs:attribute name="maximumRedeliveryDelay" type="xs:string"/>
                <xs:attribute name="retriesExhaustedLogLevel" type="loggingLevel"/>
                <xs:attribute name="retryAttemptedLogLevel" type="loggingLevel"/>
                <xs:attribute name="logRetryAttempted" type="xs:string"/>
                <xs:attribute name="logStackTrace" type="xs:string"/>
                <xs:attribute name="logRetryStackTrace" type="xs:string"/>
                <xs:attribute name="logHandled" type="xs:string"/>
                <xs:attribute name="logContinued" type="xs:string"/>
                <xs:attribute name="logExhausted" type="xs:string"/>
                <xs:attribute name="disableRedelivery" type="xs:string"/>
                <xs:attribute name="delayPattern" type="xs:string"/>
                <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractCamelThreadPoolFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
                <xs:attribute name="poolSize" type="xs:string" use="required"/>
                <xs:attribute name="maxPoolSize" type="xs:string"/>
                <xs:attribute name="keepAliveTime" type="xs:string"/>
                <xs:attribute name="timeUnit" type="xs:string"/>
                <xs:attribute name="maxQueueSize" type="xs:string"/>
                <xs:attribute name="rejectedPolicy" type="threadPoolRejectedPolicy"/>
                <xs:attribute name="threadName" type="xs:string" use="required"/>
                <xs:attribute name="scheduled" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="camelPropertyPlaceholderFunctionDefinition">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="camelProxyFactoryDefinition">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
                <xs:attribute name="serviceUrl" type="xs:string"/>
                <xs:attribute name="serviceRef" type="xs:string"/>
                <xs:attribute name="serviceInterface" type="xs:string"/>
                <xs:attribute name="camelContextId" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="camelStreamCachingStrategyDefinition">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
                <xs:attribute name="enabled" type="xs:string"/>
                <xs:attribute name="spoolDirectory" type="xs:string"/>
                <xs:attribute name="spoolChiper" type="xs:string"/>
                <xs:attribute name="spoolThreshold" type="xs:string"/>
                <xs:attribute name="spoolUsedHeapMemoryThreshold" type="xs:string"/>
                <xs:attribute name="spoolUsedHeapMemoryLimit" type="xs:string"/>
                <xs:attribute name="spoolRules" type="xs:string"/>
                <xs:attribute name="bufferSize" type="xs:string"/>
                <xs:attribute name="removeSpoolDirectoryWhenStopping" type="xs:string"/>
                <xs:attribute name="statisticsEnabled" type="xs:string"/>
                <xs:attribute name="anySpoolRules" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="patternBasedPackageScanFilter">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="abstractJsseUtilFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractCamelFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractKeyManagersParametersFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:sequence/>
                <xs:attribute name="keyPassword" type="xs:string"/>
                <xs:attribute name="provider" type="xs:string"/>
                <xs:attribute name="algorithm" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractKeyStoreParametersFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:sequence/>
                <xs:attribute name="type" type="xs:string"/>
                <xs:attribute name="password" type="xs:string"/>
                <xs:attribute name="provider" type="xs:string"/>
                <xs:attribute name="resource" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractSecureRandomParametersFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:sequence/>
                <xs:attribute name="algorithm" type="xs:string" use="required"/>
                <xs:attribute name="provider" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="abstractTrustManagersParametersFactoryBean" abstract="true">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:sequence/>
                <xs:attribute name="provider" type="xs:string"/>
                <xs:attribute name="algorithm" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="cipherSuitesParameters">
        <xs:sequence>
            <xs:element name="cipherSuite" type="xs:string" nillable="true" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="filterParameters">
        <xs:sequence>
            <xs:element name="include" type="xs:string" nillable="true" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="exclude" type="xs:string" nillable="true" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="secureSocketProtocolsParameters">
        <xs:sequence>
            <xs:element name="secureSocketProtocol" type="xs:string" nillable="true" minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="aopDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="beforeUri" type="xs:string"/>
                <xs:attribute name="afterUri" type="xs:string"/>
                <xs:attribute name="afterFinallyUri" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="output">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="processorDefinition" abstract="true">
        <xs:complexContent>
            <xs:extension base="optionalIdentifiedDefinition">
                <xs:sequence/>
                <xs:attribute name="inheritErrorHandler" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="optionalIdentifiedDefinition" abstract="true">
        <xs:sequence>
            <xs:element ref="description" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="customId" type="xs:boolean"/>
        <xs:attribute name="id" type="xs:string"/>
    </xs:complexType>


    <xs:complexType name="expressionSubElementDefinition">
        <xs:choice>
            <xs:element ref="expressionDefinition"/>
            <xs:element ref="constant"/>
            <xs:element ref="el"/>
            <xs:element ref="groovy"/>
            <xs:element ref="header"/>
            <xs:element ref="jxpath"/>
            <xs:element ref="javaScript"/>
            <xs:element ref="jsonpath"/>
            <xs:element ref="language"/>
            <xs:element ref="method"/>
            <xs:element ref="mvel"/>
            <xs:element ref="ognl"/>
            <xs:element ref="php"/>
            <xs:element ref="property"/>
            <xs:element ref="python"/>
            <xs:element ref="ref"/>
            <xs:element ref="ruby"/>
            <xs:element ref="simple"/>
            <xs:element ref="spel"/>
            <xs:element ref="sql"/>
            <xs:element ref="tokenize"/>
            <xs:element ref="vtdxml"/>
            <xs:element ref="xtokenize"/>
            <xs:element ref="xpath"/>
            <xs:element ref="xquery"/>
        </xs:choice>
    </xs:complexType>

    <xs:complexType name="expression">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="id" type="xs:ID"/>
                <xs:attribute name="trim" type="xs:boolean"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="optimisticLockRetryPolicyDefinition">
        <xs:sequence/>
        <xs:attribute name="maximumRetries" type="xs:int"/>
        <xs:attribute name="retryDelay" type="xs:long"/>
        <xs:attribute name="maximumRetryDelay" type="xs:long"/>
        <xs:attribute name="exponentialBackOff" type="xs:boolean"/>
        <xs:attribute name="randomBackOff" type="xs:boolean"/>
    </xs:complexType>


    <xs:complexType name="noOutputDefinition" abstract="true">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="catchDefinition">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:element name="exception" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="onWhen" type="whenDefinition" minOccurs="0"/>
                    <xs:element name="handled" type="expressionSubElementDefinition" minOccurs="0"/>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="whenDefinition">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="expressionNode">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:choice>
                        <xs:element ref="expressionDefinition"/>
                        <xs:element ref="constant"/>
                        <xs:element ref="el"/>
                        <xs:element ref="groovy"/>
                        <xs:element ref="header"/>
                        <xs:element ref="jxpath"/>
                        <xs:element ref="javaScript"/>
                        <xs:element ref="jsonpath"/>
                        <xs:element ref="language"/>
                        <xs:element ref="method"/>
                        <xs:element ref="mvel"/>
                        <xs:element ref="ognl"/>
                        <xs:element ref="php"/>
                        <xs:element ref="property"/>
                        <xs:element ref="python"/>
                        <xs:element ref="ref"/>
                        <xs:element ref="ruby"/>
                        <xs:element ref="simple"/>
                        <xs:element ref="spel"/>
                        <xs:element ref="sql"/>
                        <xs:element ref="tokenize"/>
                        <xs:element ref="vtdxml"/>
                        <xs:element ref="xtokenize"/>
                        <xs:element ref="xpath"/>
                        <xs:element ref="xquery"/>
                    </xs:choice>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="constants" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="convertBodyDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="type" type="xs:string" use="required"/>
                <xs:attribute name="charset" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="dataFormat">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="dynamicRouterDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="uriDelimiter" type="xs:string"/>
                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="noOutputExpressionNode">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="enrichDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="strategyMethodName" type="xs:string"/>
                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                <xs:attribute name="aggregateOnException" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="expressionNodeHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>


    <xs:complexType name="finallyDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="idempotentConsumerDefinition">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:attribute name="messageIdRepositoryRef" type="xs:string"/>
                <xs:attribute name="eager" type="xs:boolean"/>
                <xs:attribute name="skipDuplicate" type="xs:boolean"/>
                <xs:attribute name="removeOnFailure" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="inOnlyDefinition">
        <xs:complexContent>
            <xs:extension base="sendDefinition">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="sendDefinition" abstract="true">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="inOutDefinition">
        <xs:complexContent>
            <xs:extension base="sendDefinition">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="interceptDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="interceptFromDefinition">
        <xs:complexContent>
            <xs:extension base="interceptDefinition">
                <xs:sequence/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="interceptSendToEndpointDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="uri" type="xs:string" use="required"/>
                <xs:attribute name="skipSendToOriginalEndpoint" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="loadBalanceDefinition">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0">
                        <xs:element ref="failover"/>
                        <xs:element ref="random"/>
                        <xs:element name="custom" type="customLoadBalancerDefinition"/>
                        <xs:element ref="roundRobin"/>
                        <xs:element ref="sticky"/>
                        <xs:element ref="topic"/>
                        <xs:element ref="weighted"/>
                        <xs:element ref="circuitBreaker"/>
                    </xs:choice>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="failoverLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence>
                    <xs:element name="exception" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="roundRobin" type="xs:boolean"/>
                <xs:attribute name="maximumFailoverAttempts" type="xs:int"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="loadBalancer">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="randomLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="customLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="roundRobinLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="stickyLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence>
                    <xs:element name="correlationExpression" type="expressionSubElementDefinition"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="topicLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="weightedLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence/>
                <xs:attribute name="roundRobin" type="xs:boolean"/>
                <xs:attribute name="distributionRatio" type="xs:string" use="required"/>
                <xs:attribute name="distributionRatioDelimiter" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="circuitBreakerLoadBalancerDefinition">
        <xs:complexContent>
            <xs:extension base="loadBalancer">
                <xs:sequence>
                    <xs:element name="exception" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="halfOpenAfter" type="xs:long"/>
                <xs:attribute name="threshold" type="xs:int"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="loopDefinition">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:attribute name="copy" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="marshalDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0">
                        <xs:element ref="avro"/>
                        <xs:element ref="base64"/>
                        <xs:element ref="beanio"/>
                        <xs:element ref="bindy"/>
                        <xs:element ref="castor"/>
                        <xs:element ref="crypto"/>
                        <xs:element ref="csv"/>
                        <xs:element name="custom" type="customDataFormat"/>
                        <xs:element ref="flatpack"/>
                        <xs:element ref="gzip"/>
                        <xs:element ref="hl7"/>
                        <xs:element ref="jaxb"/>
                        <xs:element ref="jibx"/>
                        <xs:element ref="json"/>
                        <xs:element ref="protobuf"/>
                        <xs:element ref="rss"/>
                        <xs:element ref="secureXML"/>
                        <xs:element ref="serialization"/>
                        <xs:element ref="soapjaxb"/>
                        <xs:element ref="string"/>
                        <xs:element ref="syslog"/>
                        <xs:element ref="tidyMarkup"/>
                        <xs:element ref="xmlBeans"/>
                        <xs:element ref="xmljson"/>
                        <xs:element ref="xmlrpc"/>
                        <xs:element ref="xstream"/>
                        <xs:element ref="pgp"/>
                        <xs:element ref="zip"/>
                        <xs:element ref="zipFile"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="avroDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="instanceClassName" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="bindyDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="type" type="bindyType" use="required"/>
                <xs:attribute name="packages">
                    <xs:simpleType>
                        <xs:list itemType="xs:string"/>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="classType" type="xs:string"/>
                <xs:attribute name="locale" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="castorDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="mappingFile" type="xs:string"/>
                <xs:attribute name="validation" type="xs:boolean"/>
                <xs:attribute name="encoding" type="xs:string"/>
                <xs:attribute name="packages">
                    <xs:simpleType>
                        <xs:list itemType="xs:string"/>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="classes">
                    <xs:simpleType>
                        <xs:list itemType="xs:string"/>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="cryptoDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="algorithm" type="xs:string"/>
                <xs:attribute name="cryptoProvider" type="xs:string"/>
                <xs:attribute name="keyRef" type="xs:string"/>
                <xs:attribute name="initVectorRef" type="xs:string"/>
                <xs:attribute name="algorithmParameterRef" type="xs:string"/>
                <xs:attribute name="buffersize" type="xs:int"/>
                <xs:attribute name="macAlgorithm" type="xs:string"/>
                <xs:attribute name="shouldAppendHMAC" type="xs:boolean"/>
                <xs:attribute name="inline" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="csvDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="autogenColumns" type="xs:boolean"/>
                <xs:attribute name="delimiter" type="xs:string"/>
                <xs:attribute name="configRef" type="xs:string"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="skipFirstLine" type="xs:boolean"/>
                <xs:attribute name="lazyLoad" type="xs:boolean"/>
                <xs:attribute name="useMaps" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="customDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="flatpackDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="parserFactoryRef" type="xs:string"/>
                <xs:attribute name="definition" type="xs:string"/>
                <xs:attribute name="fixed" type="xs:boolean"/>
                <xs:attribute name="ignoreFirstRecord" type="xs:boolean"/>
                <xs:attribute name="textQualifier" type="xs:string"/>
                <xs:attribute name="delimiter" type="xs:string"/>
                <xs:attribute name="allowShortLines" type="xs:boolean"/>
                <xs:attribute name="ignoreExtraColumns" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="gzipDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="hl7DataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="validate" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="jibxDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="unmarshallClass" type="xs:string"/>
                <xs:attribute name="bindingName" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="protobufDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="instanceClass" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="rssDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="xmlSecurityDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="xmlCipherAlgorithm" type="xs:string"/>
                <xs:attribute name="passPhrase" type="xs:string"/>
                <xs:attribute name="secureTag" type="xs:string"/>
                <xs:attribute name="secureTagContents" type="xs:boolean"/>
                <xs:attribute name="keyCipherAlgorithm" type="xs:string"/>
                <xs:attribute name="recipientKeyAlias" type="xs:string"/>
                <xs:attribute name="keyOrTrustStoreParametersId" type="xs:string"/>
                <xs:attribute name="keyPassword" type="xs:string"/>
                <xs:attribute name="digestAlgorithm" type="xs:string"/>
                <xs:attribute name="mgfAlgorithm" type="xs:string"/>
                <xs:attribute name="addKeyValueForEncryptedKey" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="serializationDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="soapJaxbDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="contextPath" type="xs:string" use="required"/>
                <xs:attribute name="encoding" type="xs:string"/>
                <xs:attribute name="elementNameStrategyRef" type="xs:string"/>
                <xs:attribute name="version" type="xs:string"/>
                <xs:attribute name="namespacePrefixRef" type="xs:string"/>
                <xs:attribute name="schema" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="tidyMarkupDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="dataObjectType" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="xmlBeansDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="prettyPrint" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="xmlJsonDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="encoding" type="xs:string"/>
                <xs:attribute name="elementName" type="xs:string"/>
                <xs:attribute name="arrayName" type="xs:string"/>
                <xs:attribute name="forceTopLevelObject" type="xs:boolean"/>
                <xs:attribute name="namespaceLenient" type="xs:boolean"/>
                <xs:attribute name="rootName" type="xs:string"/>
                <xs:attribute name="skipWhitespace" type="xs:boolean"/>
                <xs:attribute name="trimSpaces" type="xs:boolean"/>
                <xs:attribute name="skipNamespaces" type="xs:boolean"/>
                <xs:attribute name="removeNamespacePrefixes" type="xs:boolean"/>
                <xs:attribute name="expandableProperties">
                    <xs:simpleType>
                        <xs:list itemType="xs:string"/>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="typeHints" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="xmlRpcDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="request" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="converterList">
        <xs:sequence>
            <xs:element name="converter" type="converterEntry" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="converterEntry">
        <xs:sequence/>
        <xs:attribute name="class" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="aliasList">
        <xs:sequence>
            <xs:element name="alias" type="aliasEntry" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="aliasEntry">
        <xs:sequence/>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="class" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="omitFieldList">
        <xs:sequence>
            <xs:element name="omitField" type="omitFieldEntry" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="omitFieldEntry">
        <xs:sequence>
            <xs:element name="field" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="class" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="implicitCollectionList">
        <xs:sequence>
            <xs:element name="class" type="implicitCollectionEntry" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="implicitCollectionEntry">
        <xs:sequence>
            <xs:element name="field" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="pgpDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="keyUserid" type="xs:string"/>
                <xs:attribute name="password" type="xs:string"/>
                <xs:attribute name="keyFileName" type="xs:string"/>
                <xs:attribute name="armored" type="xs:boolean"/>
                <xs:attribute name="integrity" type="xs:boolean"/>
                <xs:attribute name="provider" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="zipDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="compressionLevel" type="xs:int"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="zipFileDataFormat">
        <xs:complexContent>
            <xs:extension base="dataFormat">
                <xs:sequence/>
                <xs:attribute name="usingIterator" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="modelHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="multicastDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="parallelProcessing" type="xs:boolean"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="strategyMethodName" type="xs:string"/>
                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="streaming" type="xs:boolean"/>
                <xs:attribute name="stopOnException" type="xs:boolean"/>
                <xs:attribute name="timeout" type="xs:long"/>
                <xs:attribute name="onPrepareRef" type="xs:string"/>
                <xs:attribute name="shareUnitOfWork" type="xs:boolean"/>
                <xs:attribute name="parallelAggregate" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="onCompletionDefinition">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:element name="onWhen" type="whenDefinition" minOccurs="0"/>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="mode" type="onCompletionMode"/>
                <xs:attribute name="onCompleteOnly" type="xs:boolean"/>
                <xs:attribute name="onFailureOnly" type="xs:boolean"/>
                <xs:attribute name="parallelProcessing" type="xs:boolean"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="onExceptionDefinition">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:element name="exception" type="xs:string" maxOccurs="unbounded"/>
                    <xs:element name="onWhen" type="whenDefinition" minOccurs="0"/>
                    <xs:element name="retryWhile" type="expressionSubElementDefinition" minOccurs="0"/>
                    <xs:element ref="redeliveryPolicy" minOccurs="0"/>
                    <xs:element name="handled" type="expressionSubElementDefinition" minOccurs="0"/>
                    <xs:element name="continued" type="expressionSubElementDefinition" minOccurs="0"/>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="redeliveryPolicyRef" type="xs:string"/>
                <xs:attribute name="onRedeliveryRef" type="xs:string"/>
                <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="redeliveryPolicyDefinition">
        <xs:sequence/>
        <xs:attribute name="maximumRedeliveries" type="xs:string"/>
        <xs:attribute name="redeliveryDelay" type="xs:string"/>
        <xs:attribute name="asyncDelayedRedelivery" type="xs:string"/>
        <xs:attribute name="backOffMultiplier" type="xs:string"/>
        <xs:attribute name="useExponentialBackOff" type="xs:string"/>
        <xs:attribute name="collisionAvoidanceFactor" type="xs:string"/>
        <xs:attribute name="useCollisionAvoidance" type="xs:string"/>
        <xs:attribute name="maximumRedeliveryDelay" type="xs:string"/>
        <xs:attribute name="retriesExhaustedLogLevel" type="loggingLevel"/>
        <xs:attribute name="retryAttemptedLogLevel" type="loggingLevel"/>
        <xs:attribute name="logRetryAttempted" type="xs:string"/>
        <xs:attribute name="logStackTrace" type="xs:string"/>
        <xs:attribute name="logRetryStackTrace" type="xs:string"/>
        <xs:attribute name="logHandled" type="xs:string"/>
        <xs:attribute name="logContinued" type="xs:string"/>
        <xs:attribute name="logExhausted" type="xs:string"/>
        <xs:attribute name="logExhaustedMessageHistory" type="xs:string"/>
        <xs:attribute name="disableRedelivery" type="xs:string"/>
        <xs:attribute name="delayPattern" type="xs:string"/>
        <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="policyDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="pollEnrichDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:attribute name="timeout" type="xs:long"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="strategyMethodName" type="xs:string"/>
                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                <xs:attribute name="aggregateOnException" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="processorDefinitionHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="recipientListDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="delimiter" type="xs:string"/>
                <xs:attribute name="parallelProcessing" type="xs:boolean"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="strategyMethodName" type="xs:string"/>
                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="stopOnException" type="xs:boolean"/>
                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean"/>
                <xs:attribute name="streaming" type="xs:boolean"/>
                <xs:attribute name="timeout" type="xs:long"/>
                <xs:attribute name="onPrepareRef" type="xs:string"/>
                <xs:attribute name="shareUnitOfWork" type="xs:boolean"/>
                <xs:attribute name="cacheSize" type="xs:int"/>
                <xs:attribute name="parallelAggregate" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="removeHeaderDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="headerName" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="removeHeadersDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="pattern" type="xs:string" use="required"/>
                <xs:attribute name="excludePattern" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="removePropertyDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="propertyName" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="resequenceDefinition">
        <xs:complexContent>
            <xs:extension base="processorDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0">
                        <xs:element name="batch-config" type="batchResequencerConfig"/>
                        <xs:element name="stream-config" type="streamResequencerConfig"/>
                    </xs:choice>
                    <xs:choice>
                        <xs:element ref="expressionDefinition"/>
                        <xs:element ref="constant"/>
                        <xs:element ref="el"/>
                        <xs:element ref="groovy"/>
                        <xs:element ref="header"/>
                        <xs:element ref="jxpath"/>
                        <xs:element ref="javaScript"/>
                        <xs:element ref="jsonpath"/>
                        <xs:element ref="language"/>
                        <xs:element ref="method"/>
                        <xs:element ref="mvel"/>
                        <xs:element ref="ognl"/>
                        <xs:element ref="php"/>
                        <xs:element ref="property"/>
                        <xs:element ref="python"/>
                        <xs:element ref="ref"/>
                        <xs:element ref="ruby"/>
                        <xs:element ref="simple"/>
                        <xs:element ref="spel"/>
                        <xs:element ref="sql"/>
                        <xs:element ref="tokenize"/>
                        <xs:element ref="vtdxml"/>
                        <xs:element ref="xtokenize"/>
                        <xs:element ref="xpath"/>
                        <xs:element ref="xquery"/>
                    </xs:choice>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="aop"/>
                        <xs:element ref="aggregate"/>
                        <xs:element ref="bean"/>
                        <xs:element ref="doCatch"/>
                        <xs:element ref="when"/>
                        <xs:element ref="choice"/>
                        <xs:element ref="otherwise"/>
                        <xs:element ref="convertBodyTo"/>
                        <xs:element ref="delay"/>
                        <xs:element ref="dynamicRouter"/>
                        <xs:element ref="enrich"/>
                        <xs:element ref="filter"/>
                        <xs:element ref="doFinally"/>
                        <xs:element ref="idempotentConsumer"/>
                        <xs:element ref="inOnly"/>
                        <xs:element ref="inOut"/>
                        <xs:element ref="intercept"/>
                        <xs:element ref="interceptFrom"/>
                        <xs:element ref="interceptToEndpoint"/>
                        <xs:element ref="loadBalance"/>
                        <xs:element ref="log"/>
                        <xs:element ref="loop"/>
                        <xs:element ref="marshal"/>
                        <xs:element ref="multicast"/>
                        <xs:element ref="onCompletion"/>
                        <xs:element ref="onException"/>
                        <xs:element ref="pipeline"/>
                        <xs:element ref="policy"/>
                        <xs:element ref="pollEnrich"/>
                        <xs:element ref="process"/>
                        <xs:element ref="recipientList"/>
                        <xs:element ref="removeHeader"/>
                        <xs:element ref="removeHeaders"/>
                        <xs:element ref="removeProperty"/>
                        <xs:element ref="resequence"/>
                        <xs:element ref="rollback"/>
                        <xs:element ref="route"/>
                        <xs:element ref="routingSlip"/>
                        <xs:element ref="sample"/>
                        <xs:element ref="setBody"/>
                        <xs:element ref="setExchangePattern"/>
                        <xs:element ref="setFaultBody"/>
                        <xs:element ref="setHeader"/>
                        <xs:element ref="setOutHeader"/>
                        <xs:element ref="setProperty"/>
                        <xs:element ref="sort"/>
                        <xs:element ref="split"/>
                        <xs:element ref="stop"/>
                        <xs:element ref="threads"/>
                        <xs:element ref="throttle"/>
                        <xs:element ref="throwException"/>
                        <xs:element ref="to"/>
                        <xs:element ref="transacted"/>
                        <xs:element ref="transform"/>
                        <xs:element ref="doTry"/>
                        <xs:element ref="unmarshal"/>
                        <xs:element ref="validate"/>
                        <xs:element ref="wireTap"/>
                        <xs:element ref="restBinding"/>
                    </xs:choice>
                </xs:sequence>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="batchResequencerConfig">
        <xs:complexContent>
            <xs:extension base="resequencerConfig">
                <xs:sequence/>
                <xs:attribute name="batchSize" type="xs:int"/>
                <xs:attribute name="batchTimeout" type="xs:long"/>
                <xs:attribute name="allowDuplicates" type="xs:boolean"/>
                <xs:attribute name="reverse" type="xs:boolean"/>
                <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="resequencerConfig" abstract="true">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="streamResequencerConfig">
        <xs:complexContent>
            <xs:extension base="resequencerConfig">
                <xs:sequence/>
                <xs:attribute name="capacity" type="xs:int"/>
                <xs:attribute name="timeout" type="xs:long"/>
                <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean"/>
                <xs:attribute name="comparatorRef" type="xs:string"/>
                <xs:attribute name="rejectOld" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="restContextRefDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="restContextRefDefinitionHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="rollbackDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="markRollbackOnly" type="xs:boolean"/>
                <xs:attribute name="markRollbackOnlyLast" type="xs:boolean"/>
                <xs:attribute name="message" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="routeContextRefDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="routeContextRefDefinitionHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>


    <xs:complexType name="routeDefinitionHelper" final="extension restriction">
        <xs:sequence/>
    </xs:complexType>

    <xs:complexType name="routingSlipDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="uriDelimiter" type="xs:string"/>
                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean"/>
                <xs:attribute name="cacheSize" type="xs:int"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="samplingDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="samplePeriod" type="xs:long"/>
                <xs:attribute name="messageFrequency" type="xs:long"/>
                <xs:attribute name="units" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setBodyDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setExchangePatternDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="pattern" type="exchangePattern" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setFaultBodyDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setHeaderDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="headerName" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setOutHeaderDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="headerName" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="setPropertyDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="propertyName" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="sortDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:attribute name="comparatorRef" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="splitDefinition">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:attribute name="parallelProcessing" type="xs:boolean"/>
                <xs:attribute name="strategyRef" type="xs:string"/>
                <xs:attribute name="strategyMethodName" type="xs:string"/>
                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="streaming" type="xs:boolean"/>
                <xs:attribute name="stopOnException" type="xs:boolean"/>
                <xs:attribute name="timeout" type="xs:long"/>
                <xs:attribute name="onPrepareRef" type="xs:string"/>
                <xs:attribute name="shareUnitOfWork" type="xs:boolean"/>
                <xs:attribute name="parallelAggregate" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="stopDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="threadPoolProfileDefinition">
        <xs:complexContent>
            <xs:extension base="optionalIdentifiedDefinition">
                <xs:sequence>
                    <xs:element name="timeUnit" type="xs:string" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="defaultProfile" type="xs:boolean"/>
                <xs:attribute name="poolSize" type="xs:string"/>
                <xs:attribute name="maxPoolSize" type="xs:string"/>
                <xs:attribute name="keepAliveTime" type="xs:string"/>
                <xs:attribute name="maxQueueSize" type="xs:string"/>
                <xs:attribute name="rejectedPolicy" type="threadPoolRejectedPolicy"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="threadsDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="poolSize" type="xs:int"/>
                <xs:attribute name="maxPoolSize" type="xs:int"/>
                <xs:attribute name="keepAliveTime" type="xs:long"/>
                <xs:attribute name="timeUnit" type="xs:string"/>
                <xs:attribute name="maxQueueSize" type="xs:int"/>
                <xs:attribute name="threadName" type="xs:string"/>
                <xs:attribute name="rejectedPolicy" type="threadPoolRejectedPolicy"/>
                <xs:attribute name="callerRunsWhenRejected" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="throttleDefinition">
        <xs:complexContent>
            <xs:extension base="expressionNode">
                <xs:sequence/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="timePeriodMillis" type="xs:long"/>
                <xs:attribute name="asyncDelayed" type="xs:boolean"/>
                <xs:attribute name="callerRunsWhenRejected" type="xs:boolean"/>
                <xs:attribute name="rejectExecution" type="xs:boolean"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="throwExceptionDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string" use="required"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="transactedDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="tryDefinition">
        <xs:complexContent>
            <xs:extension base="output">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="unmarshalDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0">
                        <xs:element ref="avro"/>
                        <xs:element ref="base64"/>
                        <xs:element ref="beanio"/>
                        <xs:element ref="bindy"/>
                        <xs:element ref="castor"/>
                        <xs:element ref="crypto"/>
                        <xs:element ref="csv"/>
                        <xs:element name="custom" type="customDataFormat"/>
                        <xs:element ref="flatpack"/>
                        <xs:element ref="gzip"/>
                        <xs:element ref="hl7"/>
                        <xs:element ref="jaxb"/>
                        <xs:element ref="jibx"/>
                        <xs:element ref="json"/>
                        <xs:element ref="protobuf"/>
                        <xs:element ref="rss"/>
                        <xs:element ref="secureXML"/>
                        <xs:element ref="serialization"/>
                        <xs:element ref="soapjaxb"/>
                        <xs:element ref="string"/>
                        <xs:element ref="syslog"/>
                        <xs:element ref="tidyMarkup"/>
                        <xs:element ref="xmlBeans"/>
                        <xs:element ref="xmljson"/>
                        <xs:element ref="xmlrpc"/>
                        <xs:element ref="xstream"/>
                        <xs:element ref="pgp"/>
                        <xs:element ref="zip"/>
                        <xs:element ref="zipFile"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="validateDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputExpressionNode">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="whenSkipSendToEndpointDefinition">
        <xs:complexContent>
            <xs:extension base="whenDefinition">
                <xs:sequence/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="wireTapDefinition">
        <xs:complexContent>
            <xs:extension base="noOutputDefinition">
                <xs:sequence>
                    <xs:element name="body" type="expressionSubElementDefinition" minOccurs="0"/>
                    <xs:element ref="setHeader" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="ref" type="xs:string"/>
                <xs:attribute name="processorRef" type="xs:string"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
                <xs:attribute name="copy" type="xs:boolean"/>
                <xs:attribute name="onPrepareRef" type="xs:string"/>
                <xs:anyAttribute namespace="##other" processContents="skip"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="propertyDefinition">
        <xs:sequence/>
        <xs:attribute name="key" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="dataFormatsDefinition">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element ref="avro"/>
                <xs:element ref="barcode"/>
                <xs:element ref="base64"/>
                <xs:element ref="beanio"/>
                <xs:element ref="bindy"/>
                <xs:element ref="castor"/>
                <xs:element ref="crypto"/>
                <xs:element ref="csv"/>
                <xs:element name="custom" type="customDataFormat"/>
                <xs:element ref="flatpack"/>
                <xs:element ref="gzip"/>
                <xs:element ref="hl7"/>
                <xs:element ref="jaxb"/>
                <xs:element ref="jibx"/>
                <xs:element ref="json"/>
                <xs:element ref="protobuf"/>
                <xs:element ref="rss"/>
                <xs:element ref="secureXML"/>
                <xs:element ref="serialization"/>
                <xs:element ref="soapjaxb"/>
                <xs:element ref="string"/>
                <xs:element ref="syslog"/>
                <xs:element ref="tidyMarkup"/>
                <xs:element ref="xmlBeans"/>
                <xs:element ref="xmljson"/>
                <xs:element ref="xmlrpc"/>
                <xs:element ref="xstream"/>
                <xs:element ref="pgp"/>
                <xs:element ref="zip"/>
                <xs:element ref="zipFile"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>


    <xs:complexType name="namespaceAwareExpression" abstract="true">
        <xs:simpleContent>
            <xs:extension base="expression"/>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="propertyExpression">
        <xs:simpleContent>
            <xs:extension base="expression"/>
        </xs:simpleContent>
    </xs:complexType>


    <xs:complexType name="spELExpression">
        <xs:simpleContent>
            <xs:extension base="expression"/>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="tokenizerExpression">
        <xs:simpleContent>
            <xs:extension base="expression">
                <xs:attribute name="token" type="xs:string" use="required"/>
                <xs:attribute name="endToken" type="xs:string"/>
                <xs:attribute name="inheritNamespaceTagName" type="xs:string"/>
                <xs:attribute name="headerName" type="xs:string"/>
                <xs:attribute name="regex" type="xs:boolean"/>
                <xs:attribute name="xml" type="xs:boolean"/>
                <xs:attribute name="includeTokens" type="xs:boolean"/>
                <xs:attribute name="group" type="xs:int"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="vtdXmlExpression">
        <xs:simpleContent>
            <xs:extension base="namespaceAwareExpression"/>
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="xmlTokenizerExpression">
        <xs:simpleContent>
            <xs:extension base="namespaceAwareExpression">
                <xs:attribute name="headerName" type="xs:string"/>
                <xs:attribute name="mode" type="xs:string"/>
                <xs:attribute name="group" type="xs:int"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>


    <xs:complexType name="deleteVerbDefinition">
        <xs:complexContent>
            <xs:extension base="verbDefinition">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="verbDefinition">
        <xs:complexContent>
            <xs:extension base="optionalIdentifiedDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0">
                        <xs:element ref="to"/>
                        <xs:element ref="route"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="method" type="xs:string"/>
                <xs:attribute name="uri" type="xs:string"/>
                <xs:attribute name="consumes" type="xs:string"/>
                <xs:attribute name="produces" type="xs:string"/>
                <xs:attribute name="bindingMode" type="restBindingMode"/>
                <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean"/>
                <xs:attribute name="enableCORS" type="xs:boolean"/>
                <xs:attribute name="type" type="xs:string"/>
                <xs:attribute name="outType" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="getVerbDefinition">
        <xs:complexContent>
            <xs:extension base="verbDefinition">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="headVerbDefinition">
        <xs:complexContent>
            <xs:extension base="verbDefinition">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="postVerbDefinition">
        <xs:complexContent>
            <xs:extension base="verbDefinition">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="restConfigurationDefinition">
        <xs:sequence>
            <xs:element name="componentProperty" type="restPropertyDefinition" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="endpointProperty" type="restPropertyDefinition" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="consumerProperty" type="restPropertyDefinition" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="dataFormatProperty" type="restPropertyDefinition" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="corsHeaders" type="restPropertyDefinition" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="component" type="xs:string"/>
        <xs:attribute name="scheme" type="xs:string"/>
        <xs:attribute name="host" type="xs:string"/>
        <xs:attribute name="port" type="xs:string"/>
        <xs:attribute name="contextPath" type="xs:string"/>
        <xs:attribute name="hostNameResolver" type="restHostNameResolver"/>
        <xs:attribute name="bindingMode" type="restBindingMode"/>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean"/>
        <xs:attribute name="enableCORS" type="xs:boolean"/>
        <xs:attribute name="jsonDataFormat" type="xs:string"/>
        <xs:attribute name="xmlDataFormat" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="restPropertyDefinition">
        <xs:sequence/>
        <xs:attribute name="key" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="restDefinition">
        <xs:complexContent>
            <xs:extension base="optionalIdentifiedDefinition">
                <xs:sequence>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="verb"/>
                        <xs:element ref="delete"/>
                        <xs:element ref="get"/>
                        <xs:element ref="head"/>
                        <xs:element ref="post"/>
                        <xs:element ref="put"/>
                    </xs:choice>
                </xs:sequence>
                <xs:attribute name="path" type="xs:string"/>
                <xs:attribute name="consumes" type="xs:string"/>
                <xs:attribute name="produces" type="xs:string"/>
                <xs:attribute name="bindingMode" type="restBindingMode"/>
                <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean"/>
                <xs:attribute name="enableCORS" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="restsDefinition">
        <xs:complexContent>
            <xs:extension base="optionalIdentifiedDefinition">
                <xs:sequence>
                    <xs:element ref="rest" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="camelConsumerTemplateFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractCamelConsumerTemplateFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="camelContext">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="abstractCamelContextFactoryBean">
                    <xs:sequence>
                        <xs:element ref="properties" minOccurs="0"/>
                        <xs:element ref="propertyPlaceholder" minOccurs="0"/>
                        <xs:element name="package" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="packageScan" minOccurs="0"/>
                        <xs:element ref="contextScan" minOccurs="0"/>
                        <xs:element ref="streamCaching" minOccurs="0"/>
                        <xs:element ref="jmxAgent" minOccurs="0"/>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:element ref="template"/>
                            <xs:element ref="consumerTemplate"/>
                            <xs:element ref="proxy"/>
                            <xs:element ref="export"/>
                            <xs:element ref="errorHandler"/>
                        </xs:choice>
                        <xs:element ref="routeBuilder" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="routeContextRef" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="restContextRef" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="threadPoolProfile" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="threadPool" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="endpoint" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="dataFormats" minOccurs="0"/>
                        <xs:element ref="redeliveryPolicyProfile" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="onException" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="onCompletion" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="intercept" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="interceptFrom" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element name="interceptSendToEndpoint" type="interceptSendToEndpointDefinition"
                                    minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="restConfiguration" minOccurs="0"/>
                        <xs:element ref="rest" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="route" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="depends-on" type="xs:string"/>
                    <xs:attribute name="trace" type="xs:string"/>
                    <xs:attribute name="messageHistory" type="xs:string"/>
                    <xs:attribute name="streamCache" type="xs:string"/>
                    <xs:attribute name="delayer" type="xs:string"/>
                    <xs:attribute name="handleFault" type="xs:string"/>
                    <xs:attribute name="errorHandlerRef" type="xs:string"/>
                    <xs:attribute name="autoStartup" type="xs:string"/>
                    <xs:attribute name="shutdownEager" type="xs:string"/>
                    <xs:attribute name="useMDCLogging" type="xs:string"/>
                    <xs:attribute name="useBreadcrumb" type="xs:string"/>
                    <xs:attribute name="allowUseOriginalMessage" type="xs:string"/>
                    <xs:attribute name="runtimeEndpointRegistryEnabled" type="xs:string"/>
                    <xs:attribute name="managementNamePattern" type="xs:string"/>
                    <xs:attribute name="threadNamePattern" type="xs:string"/>
                    <xs:attribute name="shutdownRoute" type="shutdownRoute"/>
                    <xs:attribute name="shutdownRunningTask" type="shutdownRunningTask"/>
                    <xs:attribute name="lazyLoadTypeConverters" type="xs:boolean"/>
                    <xs:attribute name="typeConverterStatisticsEnabled" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="camelProducerTemplateFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractCamelProducerTemplateFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="errorHandlerDefinition">
        <xs:complexContent>
            <xs:extension base="identifiedType">
                <xs:sequence>
                    <xs:element name="redeliveryPolicy" type="camelRedeliveryPolicyFactoryBean" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="type" type="errorHandlerType"/>
                <xs:attribute name="deadLetterUri" type="xs:string"/>
                <xs:attribute name="level" type="loggingLevel"/>
                <xs:attribute name="rollbackLoggingLevel" type="loggingLevel"/>
                <xs:attribute name="logName" type="xs:string"/>
                <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
                <xs:attribute name="transactionTemplateRef" type="xs:string"/>
                <xs:attribute name="transactionManagerRef" type="xs:string"/>
                <xs:attribute name="onRedeliveryRef" type="xs:string"/>
                <xs:attribute name="retryWhileRef" type="xs:string"/>
                <xs:attribute name="redeliveryPolicyRef" type="xs:string"/>
                <xs:attribute name="executorServiceRef" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="camelRedeliveryPolicyFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractCamelRedeliveryPolicyFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="camelThreadPoolFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractCamelThreadPoolFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="keyManagersParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractKeyManagersParametersFactoryBean">
                <xs:sequence>
                    <xs:element name="keyStore" type="keyStoreParametersFactoryBean" minOccurs="0"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="keyStoreParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractKeyStoreParametersFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="sslContextClientParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:all>
                    <xs:element name="cipherSuites" type="cipherSuitesParameters" minOccurs="0"/>
                    <xs:element name="cipherSuitesFilter" type="filterParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocols" type="secureSocketProtocolsParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocolsFilter" type="filterParameters" minOccurs="0"/>
                </xs:all>
                <xs:attribute name="sessionTimeout" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="sslContextParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:all>
                    <xs:element name="cipherSuites" type="cipherSuitesParameters" minOccurs="0"/>
                    <xs:element name="cipherSuitesFilter" type="filterParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocols" type="secureSocketProtocolsParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocolsFilter" type="filterParameters" minOccurs="0"/>
                    <xs:element name="keyManagers" type="keyManagersParametersFactoryBean" minOccurs="0"/>
                    <xs:element name="trustManagers" type="trustManagersParametersFactoryBean" minOccurs="0"/>
                    <xs:element name="secureRandom" type="secureRandomParametersFactoryBean" minOccurs="0"/>
                    <xs:element name="clientParameters" type="sslContextClientParametersFactoryBean" minOccurs="0"/>
                    <xs:element name="serverParameters" type="sslContextServerParametersFactoryBean" minOccurs="0"/>
                </xs:all>
                <xs:attribute name="sessionTimeout" type="xs:string"/>
                <xs:attribute name="provider" type="xs:string"/>
                <xs:attribute name="secureSocketProtocol" type="xs:string"/>
                <xs:attribute name="certAlias" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="trustManagersParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractTrustManagersParametersFactoryBean">
                <xs:sequence>
                    <xs:element name="keyStore" type="keyStoreParametersFactoryBean" minOccurs="0"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="secureRandomParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractSecureRandomParametersFactoryBean">
                <xs:sequence/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="sslContextServerParametersFactoryBean">
        <xs:complexContent>
            <xs:extension base="abstractJsseUtilFactoryBean">
                <xs:all>
                    <xs:element name="cipherSuites" type="cipherSuitesParameters" minOccurs="0"/>
                    <xs:element name="cipherSuitesFilter" type="filterParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocols" type="secureSocketProtocolsParameters" minOccurs="0"/>
                    <xs:element name="secureSocketProtocolsFilter" type="filterParameters" minOccurs="0"/>
                </xs:all>
                <xs:attribute name="sessionTimeout" type="xs:string"/>
                <xs:attribute name="clientAuthentication" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="exchangePattern">
        <xs:restriction base="xs:string">
            <xs:enumeration value="InOnly"/>
            <xs:enumeration value="RobustInOnly"/>
            <xs:enumeration value="OutOptionalIn"/>
            <xs:enumeration value="OutIn"/>
            <xs:enumeration value="RobustOutOnly"/>
            <xs:enumeration value="InOptionalOut"/>
            <xs:enumeration value="OutOnly"/>
            <xs:enumeration value="InOut"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="loggingLevel">
        <xs:restriction base="xs:string">
            <xs:enumeration value="INFO"/>
            <xs:enumeration value="TRACE"/>
            <xs:enumeration value="DEBUG"/>
            <xs:enumeration value="OFF"/>
            <xs:enumeration value="ERROR"/>
            <xs:enumeration value="WARN"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="threadPoolRejectedPolicy">
        <xs:restriction base="xs:string">
            <xs:enumeration value="DiscardOldest"/>
            <xs:enumeration value="CallerRuns"/>
            <xs:enumeration value="Abort"/>
            <xs:enumeration value="Discard"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="bindyType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Csv"/>
            <xs:enumeration value="KeyValue"/>
            <xs:enumeration value="Fixed"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="jsonLibrary">
        <xs:restriction base="xs:string">
            <xs:enumeration value="XStream"/>
            <xs:enumeration value="Jackson"/>
            <xs:enumeration value="Gson"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="onCompletionMode">
        <xs:restriction base="xs:string">
            <xs:enumeration value="BeforeConsumer"/>
            <xs:enumeration value="AfterConsumer"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="shutdownRoute">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Defer"/>
            <xs:enumeration value="Default"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="shutdownRunningTask">
        <xs:restriction base="xs:string">
            <xs:enumeration value="CompleteAllTasks"/>
            <xs:enumeration value="CompleteCurrentTaskOnly"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="restBindingMode">
        <xs:restriction base="xs:string">
            <xs:enumeration value="xml"/>
            <xs:enumeration value="json_xml"/>
            <xs:enumeration value="auto"/>
            <xs:enumeration value="json"/>
            <xs:enumeration value="off"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="restHostNameResolver">
        <xs:restriction base="xs:string">
            <xs:enumeration value="localHostName"/>
            <xs:enumeration value="localIp"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="errorHandlerType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="TransactionErrorHandler"/>
            <xs:enumeration value="NoErrorHandler"/>
            <xs:enumeration value="DeadLetterChannel"/>
            <xs:enumeration value="LoggingErrorHandler"/>
            <xs:enumeration value="DefaultErrorHandler"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>

